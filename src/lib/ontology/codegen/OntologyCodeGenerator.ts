import { ImportGenerator } from './ImportGenerator'
import { EntityGenerator } from './EntityGenerator'
import { EdgeGenerator } from './EdgeGenerator'
import { MapGenerator } from './MapGenerator'
import { FormatterService } from './FormatterService'
import { PythonValidator } from './PythonValidator'
import { DependencyResolver } from './DependencyResolver'
import { OntologyRecord, EntityDefinitionRecord, EdgeDefinitionRecord } from '../../types/airtable'

export interface GeneratedCode {
  code: string
  isValid: boolean
  errors: ValidationError[]
  metadata: CodeMetadata
}

export interface ValidationError {
  line?: number
  column?: number
  message: string
  severity: 'error' | 'warning'
}

export interface CodeMetadata {
  version: string
  timestamp: Date
  checksum: string
  ontologyName: string
  ontologyVersion: string
  entityCount: number
  edgeCount: number
}

export interface GenerationOptions {
  includeValidators?: boolean
  includeHelpers?: boolean
  includeTests?: boolean
  format?: 'python' | 'json' | 'yaml'
  minify?: boolean
}

export class OntologyCodeGenerator {
  private ontology: OntologyRecord
  private entities: EntityDefinitionRecord[]
  private edges: EdgeDefinitionRecord[]
  private importGenerator: ImportGenerator
  private entityGenerator: EntityGenerator
  private edgeGenerator: EdgeGenerator
  private mapGenerator: MapGenerator
  private formatter: FormatterService
  private validator: PythonValidator
  private dependencyResolver: DependencyResolver

  constructor(
    ontology: OntologyRecord,
    entities: EntityDefinitionRecord[],
    edges: EdgeDefinitionRecord[]
  ) {
    this.ontology = ontology
    this.entities = entities
    this.edges = edges
    this.importGenerator = new ImportGenerator()
    this.entityGenerator = new EntityGenerator()
    this.edgeGenerator = new EdgeGenerator()
    this.mapGenerator = new MapGenerator()
    this.formatter = new FormatterService()
    this.validator = new PythonValidator()
    this.dependencyResolver = new DependencyResolver()
  }

  async generate(options: GenerationOptions = {}): Promise<GeneratedCode> {
    try {
      // Resolve dependencies and order definitions
      this.dependencyResolver.buildGraph(this.entities, this.edges)
      const ordered = this.dependencyResolver.getOrderedDefinitions()
      
      // Check for circular dependencies
      const cycles = this.dependencyResolver.detectCycles()
      if (cycles.length > 0) {
        console.warn('Circular dependencies detected:', cycles)
      }
      
      // Generate code sections with ordered definitions
      const header = this.generateHeader()
      const imports = this.importGenerator.generate(ordered.entities, ordered.edges)
      const entityClasses = this.entityGenerator.generateAll(ordered.entities)
      const edgeClasses = this.edgeGenerator.generateAll(ordered.edges)
      const edgeMap = this.mapGenerator.generate(ordered.edges)
      
      // Optional sections
      const helpers = options.includeHelpers ? this.generateHelpers() : ''
      const validators = options.includeValidators ? this.generateValidators() : ''
      
      // Assemble the complete module
      const code = this.assembleModule({
        header,
        imports,
        entityClasses,
        edgeClasses,
        edgeMap,
        helpers,
        validators
      })

      // Format the code
      const formatted = await this.formatter.format(code)
      
      // Validate the code
      const validation = await this.validator.validate(formatted)
      
      // Generate metadata
      const metadata = this.generateMetadata()

      return {
        code: formatted,
        isValid: validation.isValid,
        errors: validation.errors,
        metadata
      }
    } catch (error) {
      return {
        code: '',
        isValid: false,
        errors: [{
          message: error instanceof Error ? error.message : 'Code generation failed',
          severity: 'error'
        }],
        metadata: this.generateMetadata()
      }
    }
  }

  private generateHeader(): string {
    const timestamp = new Date().toISOString()
    const ontologyName = this.ontology.fields.Name || 'Unnamed Ontology'
    const ontologyVersion = this.ontology.fields.Version || '1.0.0'
    const description = this.ontology.fields.Description || ''

    return `"""
${ontologyName} - Ontology Definition Module
${description ? `\n${description}\n` : ''}
Generated by Krypton Graph
Date: ${timestamp}
Ontology Version: ${ontologyVersion}

This module contains Pydantic models for entities and edges,
along with the edge type mapping configuration.
Compatible with Graphiti API v0.3+
"""

__version__ = "${ontologyVersion}"
__generated_at__ = "${timestamp}"
__generator__ = "krypton-graph-1.0.0"
`
  }

  private assembleModule(sections: {
    header: string
    imports: string
    entityClasses: string
    edgeClasses: string
    edgeMap: string
    helpers: string
    validators: string
  }): string {
    const parts = [
      sections.header,
      sections.imports,
      '',
      '# ============================================================================',
      '# Entity Definitions',
      '# ============================================================================',
      '',
      sections.entityClasses,
      '',
      '# ============================================================================',
      '# Edge Definitions',
      '# ============================================================================',
      '',
      sections.edgeClasses,
      '',
      '# ============================================================================',
      '# Edge Type Mapping',
      '# ============================================================================',
      '',
      sections.edgeMap
    ]

    if (sections.helpers) {
      parts.push(
        '',
        '# ============================================================================',
        '# Helper Functions',
        '# ============================================================================',
        '',
        sections.helpers
      )
    }

    if (sections.validators) {
      parts.push(
        '',
        '# ============================================================================',
        '# Custom Validators',
        '# ============================================================================',
        '',
        sections.validators
      )
    }

    return parts.filter(Boolean).join('\n')
  }

  private generateHelpers(): string {
    return `
def get_edge_type(source_type: str, target_type: str, edge_name: str = None) -> str:
    """
    Find the appropriate edge type for given source and target.
    
    Args:
        source_type: The type of the source entity
        target_type: The type of the target entity
        edge_name: Optional specific edge name to look for
    
    Returns:
        The matching edge type name or "*" as fallback
    """
    if edge_name and edge_name in edge_type_map:
        config = edge_type_map[edge_name]
        source_match = (
            config.get("source") == source_type or
            source_type in config.get("source", []) or
            config.get("source") == "*"
        )
        target_match = (
            config.get("target") == target_type or
            target_type in config.get("target", []) or
            config.get("target") == "*"
        )
        if source_match and target_match:
            return edge_name
    
    # Search for matching edge type
    for edge_type, config in edge_type_map.items():
        if edge_type == "*":
            continue
        
        source = config.get("source")
        target = config.get("target")
        
        source_match = (
            source == source_type or
            (isinstance(source, list) and source_type in source) or
            source == "*"
        )
        
        target_match = (
            target == target_type or
            (isinstance(target, list) and target_type in target) or
            target == "*"
        )
        
        if source_match and target_match:
            return edge_type
    
    return "*"  # Fallback to generic edge


def validate_edge_creation(source_type: str, target_type: str, edge_type: str) -> bool:
    """
    Validate if an edge can be created between two entity types.
    
    Args:
        source_type: The type of the source entity
        target_type: The type of the target entity
        edge_type: The edge type to create
    
    Returns:
        True if the edge is valid, False otherwise
    """
    if edge_type not in edge_type_map:
        return False
    
    config = edge_type_map[edge_type]
    source = config.get("source")
    target = config.get("target")
    
    source_valid = (
        source == "*" or
        source == source_type or
        (isinstance(source, list) and source_type in source)
    )
    
    target_valid = (
        target == "*" or
        target == target_type or
        (isinstance(target, list) and target_type in target)
    )
    
    return source_valid and target_valid
`
  }

  private generateValidators(): string {
    // This would generate custom validators based on the ontology
    // For now, returning a placeholder
    return `
# Custom validators can be added here
# Example:
# @validator('field_name')
# def validate_field(cls, v):
#     if not v:
#         raise ValueError('Field cannot be empty')
#     return v
`
  }

  private generateMetadata(): CodeMetadata {
    return {
      version: this.ontology.fields.Version || '1.0.0',
      timestamp: new Date(),
      checksum: this.calculateChecksum(),
      ontologyName: this.ontology.fields.Name || 'Unnamed',
      ontologyVersion: this.ontology.fields.Version || '1.0.0',
      entityCount: this.entities.length,
      edgeCount: this.edges.length
    }
  }

  private calculateChecksum(): string {
    // Simple checksum calculation - in production, use crypto
    const content = JSON.stringify({
      ontology: this.ontology.id,
      entities: this.entities.map(e => e.id),
      edges: this.edges.map(e => e.id)
    })
    
    let hash = 0
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i)
      hash = ((hash << 5) - hash) + char
      hash = hash & hash
    }
    
    return Math.abs(hash).toString(16).padStart(8, '0')
  }

  async generatePackage(): Promise<ExportPackage> {
    const mainCode = await this.generate({ 
      includeHelpers: true, 
      includeValidators: true 
    })
    
    return {
      files: {
        'ontology.py': mainCode.code,
        'requirements.txt': this.generateRequirements(),
        'README.md': this.generateReadme(),
        '__init__.py': this.generateInit()
      },
      metadata: mainCode.metadata
    }
  }

  private generateRequirements(): string {
    return `# Requirements for ${this.ontology.fields.Name} Ontology
pydantic>=2.0.0
typing-extensions>=4.0.0
python-dateutil>=2.8.0
`
  }

  private generateReadme(): string {
    return `# ${this.ontology.fields.Name} Ontology

${this.ontology.fields.Description || 'Ontology definition for knowledge graph'}

## Version
${this.ontology.fields.Version || '1.0.0'}

## Generated
${new Date().toISOString()}

## Usage

\`\`\`python
from ontology import *

# Create entity instances
person = Person(
    first_name="John",
    last_name="Doe"
)

company = Company(
    name="Acme Corp"
)

# Create edge instances
employment = Employment(
    role="Software Engineer",
    start_date=datetime.now()
)
\`\`\`

## Entity Types
- ${this.entities.map(e => e.fields['Entity Name']).join('\n- ')}

## Edge Types
- ${this.edges.map(e => e.fields['Edge Name']).join('\n- ')}
`
  }

  private generateInit(): string {
    const entityNames = this.entities.map(e => e.fields['Entity Name']).filter(Boolean)
    const edgeNames = this.edges.map(e => e.fields['Edge Name']).filter(Boolean)
    
    return `"""
${this.ontology.fields.Name} Ontology Package
"""

from .ontology import (
    # Entities
    ${entityNames.join(',\n    ')},
    
    # Edges
    ${edgeNames.join(',\n    ')},
    
    # Edge mapping
    edge_type_map,
    
    # Helpers
    get_edge_type,
    validate_edge_creation
)

__all__ = [
    # Entities
    ${entityNames.map(n => `"${n}"`).join(',\n    ')},
    
    # Edges
    ${edgeNames.map(n => `"${n}"`).join(',\n    ')},
    
    # Utilities
    "edge_type_map",
    "get_edge_type",
    "validate_edge_creation"
]
`
  }
}

export interface ExportPackage {
  files: {
    [filename: string]: string
  }
  metadata: CodeMetadata
}