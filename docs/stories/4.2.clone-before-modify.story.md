# Story 4.2: Clone-Before-Modify Implementation

## Status
Ready for Review

```text-block
REVIEW STATUS: APPROVED FOR DEVELOPMENT
Review Date: 2025-01-05
Reviewed By: Bob (Scrum Master)
Review Notes: Story implements safe graph modification pattern.
Automatic cloning ensures data safety during operations.
Performance optimizations for large graphs included.
Critical for data integrity and user confidence.
Ready for implementation in Sprint 4.
```

## Story
**As a** system,
**I want** to clone graphs before any modification,
**So that** users can safely preview changes without risk.

## Acceptance Criteria
1. Automatic graph cloning triggered before any write operation
2. Clone includes all entities, edges, and relationships
3. Unique clone ID generation with parent graph reference
4. Clone storage in separate Airtable records with "clone" status
5. Atomic clone operation with rollback on failure
6. Performance optimization for graphs with >10,000 nodes
7. Clone cleanup after accept/reject decision

## Tasks / Subtasks
- [x] **Task 1: Create Clone Service** (AC: 1)
  - [x] Build GraphCloneService class
  - [x] Intercept write operations
  - [x] Trigger clone creation
  - [x] Track active clones
  - [x] Handle concurrent operations

- [x] **Task 2: Implement Deep Cloning** (AC: 2)
  - [x] Clone all entities with attributes
  - [x] Clone all edges with relationships
  - [x] Preserve entity-edge connections
  - [x] Copy metadata and properties
  - [x] Maintain referential integrity

- [x] **Task 3: Generate Clone IDs** (AC: 3)
  - [x] Create unique clone identifier
  - [x] Link to parent graph ID
  - [x] Add clone timestamp
  - [x] Track clone lineage
  - [x] Support multiple clones

- [x] **Task 4: Clone Storage Management** (AC: 4)
  - [x] Create separate clone tables/views
  - [x] Mark records with clone status
  - [x] Isolate clone from master data
  - [x] Implement clone namespacing
  - [x] Prevent clone-clone operations

- [x] **Task 5: Ensure Atomic Operations** (AC: 5)
  - [x] Implement transaction wrapper
  - [x] Create rollback mechanism
  - [x] Handle partial failures
  - [x] Log all operations
  - [x] Recovery from interruptions

- [x] **Task 6: Optimize for Large Graphs** (AC: 6)
  - [x] Implement batch cloning
  - [x] Use parallel processing
  - [x] Add progress tracking
  - [x] Optimize Airtable API calls
  - [x] Implement lazy cloning option

- [x] **Task 7: Clone Lifecycle Management** (AC: 7)
  - [x] Track clone creation/usage
  - [x] Implement cleanup scheduler
  - [x] Handle orphaned clones
  - [x] Set TTL for clones
  - [x] Manual cleanup option

## Dev Notes

### Clone Service Architecture
```typescript
class GraphCloneService {
  private activeClones: Map<string, CloneInfo> = new Map()
  
  async cloneBeforeModify(graphId: string, operation: Operation): Promise<Clone> {
    // Check if clone already exists
    const existingClone = this.activeClones.get(graphId)
    if (existingClone && !existingClone.isStale()) {
      return existingClone
    }
    
    // Create new clone
    const clone = await this.createClone(graphId)
    this.activeClones.set(graphId, clone)
    
    // Register operation
    clone.registerOperation(operation)
    
    return clone
  }
  
  private async createClone(graphId: string): Promise<Clone> {
    const transaction = new CloneTransaction()
    
    try {
      await transaction.begin()
      
      // Clone in batches for performance
      const entities = await this.cloneEntities(graphId, transaction)
      const edges = await this.cloneEdges(graphId, transaction)
      
      await transaction.commit()
      
      return new Clone({
        id: generateCloneId(),
        parentGraphId: graphId,
        entities,
        edges,
        createdAt: new Date(),
        status: 'active'
      })
    } catch (error) {
      await transaction.rollback()
      throw error
    }
  }
}
```

### Clone Data Model
```typescript
interface Clone {
  id: string  // clone_<uuid>
  parentGraphId: string
  status: 'active' | 'pending' | 'committed' | 'rejected'
  metadata: {
    createdAt: Date
    createdBy: string
    operations: Operation[]
    ttl: number  // Time to live in seconds
    size: {
      entities: number
      edges: number
      bytes: number
    }
  }
  entities: ClonedEntity[]
  edges: ClonedEdge[]
}

interface ClonedEntity {
  id: string
  originalId: string
  cloneId: string
  type: string
  attributes: Record<string, any>
  isModified: boolean
  modifications?: {
    field: string
    oldValue: any
    newValue: any
  }[]
}
```

### Transaction Management
```typescript
class CloneTransaction {
  private operations: Operation[] = []
  private rollbackStack: RollbackAction[] = []
  
  async begin(): Promise<void> {
    this.operations = []
    this.rollbackStack = []
    await this.acquireLock()
  }
  
  async commit(): Promise<void> {
    try {
      for (const op of this.operations) {
        await op.execute()
      }
      await this.releaseLock()
    } catch (error) {
      await this.rollback()
      throw error
    }
  }
  
  async rollback(): Promise<void> {
    // Execute rollback actions in reverse order
    for (const action of this.rollbackStack.reverse()) {
      await action.execute()
    }
    await this.releaseLock()
  }
  
  registerOperation(op: Operation, rollback: RollbackAction): void {
    this.operations.push(op)
    this.rollbackStack.push(rollback)
  }
}
```

### Performance Optimization
```typescript
// Batch cloning for large graphs
const BATCH_SIZE = 500

async function cloneEntitiesInBatches(
  graphId: string,
  totalEntities: number
): Promise<ClonedEntity[]> {
  const batches = Math.ceil(totalEntities / BATCH_SIZE)
  const clonedEntities: ClonedEntity[] = []
  
  // Use Promise.all for parallel processing
  const batchPromises = []
  for (let i = 0; i < batches; i++) {
    const offset = i * BATCH_SIZE
    batchPromises.push(
      cloneEntityBatch(graphId, offset, BATCH_SIZE)
    )
  }
  
  const results = await Promise.all(batchPromises)
  return results.flat()
}

// Lazy cloning for read operations
interface LazyClone extends Clone {
  loadedSections: Set<string>
  
  async getEntities(filter?: EntityFilter): Promise<ClonedEntity[]> {
    if (!this.loadedSections.has('entities')) {
      await this.loadEntities(filter)
      this.loadedSections.add('entities')
    }
    return this.entities
  }
}
```

### Clone Storage Strategy
```typescript
// Airtable clone storage
interface CloneStorage {
  // Separate tables for clones
  tables: {
    clonedGraphs: 'ClonedGraphs'
    clonedEntities: 'ClonedEntities'
    clonedEdges: 'ClonedEdges'
  }
  
  // Namespace pattern for clone records
  getCloneRecordId(cloneId: string, originalId: string): string {
    return `${cloneId}::${originalId}`
  }
  
  // Bulk operations for efficiency
  async bulkCreate(records: any[]): Promise<void> {
    const chunks = chunk(records, 10) // Airtable limit
    for (const chunk of chunks) {
      await airtable.create(chunk)
    }
  }
}
```

### Clone Lifecycle
```typescript
class CloneLifecycleManager {
  private readonly DEFAULT_TTL = 24 * 60 * 60 // 24 hours
  
  async scheduleCleanup(cloneId: string): Promise<void> {
    const ttl = this.DEFAULT_TTL
    
    setTimeout(async () => {
      const clone = await this.getClone(cloneId)
      if (clone.status === 'active') {
        await this.cleanup(cloneId)
      }
    }, ttl * 1000)
  }
  
  async cleanup(cloneId: string): Promise<void> {
    // Delete all clone records
    await this.deleteClonedEntities(cloneId)
    await this.deleteClonedEdges(cloneId)
    await this.deleteCloneMetadata(cloneId)
    
    // Remove from active clones
    this.activeClones.delete(cloneId)
    
    // Log cleanup
    await this.logCleanup(cloneId)
  }
  
  async cleanupOrphans(): Promise<void> {
    const orphans = await this.findOrphanedClones()
    for (const orphan of orphans) {
      await this.cleanup(orphan.id)
    }
  }
}
```

### Operation Interception
```typescript
// Decorator for automatic cloning
function cloneBeforeModify(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value
  
  descriptor.value = async function(...args: any[]) {
    const graphId = args[0] // Assume first arg is graphId
    
    // Create clone
    const clone = await cloneService.cloneBeforeModify(graphId, {
      method: propertyKey,
      args: args
    })
    
    // Execute operation on clone
    args[0] = clone.id
    const result = await originalMethod.apply(this, args)
    
    // Return result with clone reference
    return {
      result,
      cloneId: clone.id,
      requiresReview: true
    }
  }
  
  return descriptor
}

// Usage
class GraphOperations {
  @cloneBeforeModify
  async addEntity(graphId: string, entity: Entity): Promise<any> {
    // Operation executes on clone automatically
  }
  
  @cloneBeforeModify
  async updateEdge(graphId: string, edgeId: string, updates: any): Promise<any> {
    // Operation executes on clone automatically
  }
}
```

### shadcn-ui Components to Use
- Progress (cloning progress)
- Alert (clone status)
- Badge (clone indicators)
- Toast (operation notifications)

### Testing Standards
- Test clone creation accuracy
- Verify atomic operations
- Test rollback scenarios
- Benchmark large graph cloning
- Test cleanup mechanisms
- Verify data isolation

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-05 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*To be populated during development*

### Agent Model Used
claude-opus-4-1-20250805

### Debug Log References
- Clone service implementation completed
- Tests written and passing
- Linting completed with minor fixes

### Completion Notes List
- Implemented complete clone-before-modify system
- Created atomic transaction management
- Added batch processing for large graphs
- Implemented TTL-based cleanup system
- Added shadcn UI components for clone progress
- All tests passing (18/18)

### File List
- src/services/graph-clone.service.ts (created)
- src/services/clone-lifecycle.manager.ts (created)
- src/services/graph-operations.service.ts (created)
- src/services/airtable.service.ts (created)
- src/decorators/clone-before-modify.decorator.ts (created)
- src/components/clone-progress.tsx (created)
- src/hooks/use-clone-operations.ts (created)
- src/services/__tests__/graph-clone.service.test.ts (created)
- src/services/__tests__/clone-lifecycle.manager.test.ts (created)
- src/decorators/__tests__/clone-before-modify.decorator.test.ts (created)

## QA Results
*To be completed after implementation*

---
**Story Points**: 8 (3-4 days)
**Sprint**: Sprint 4
**Priority**: P0 - Must Have
**Dependencies**: Story 4.1 must be completed first