# Story 3.5: Ontology Code Generation and Export

## Status
Ready for Review

```text-block
REVIEW STATUS: APPROVED FOR DEVELOPMENT
Review Date: 2025-01-05
Reviewed By: Bob (Scrum Master)
Review Notes: Ontology code generation story approved for development.
Complete Python module generation with Pydantic models.
Edge type map dictionary with fallback patterns included.
Proper import management and dependency ordering.
Syntax validation ensures generated code is valid Python.
Multi-file export supports complete package generation.
Version tracking enables git-friendly development.
Depends on Stories 3.1, 3.2, and 3.3 for complete ontology.
Critical for Graphiti API integration.
```

## Story
**As a** user,
**I want** to generate and export my ontology as Python code,
**So that** I can use it with the Graphiti API.

## Acceptance Criteria
1. Generate complete Python module with all entity/edge type definitions
2. Include proper imports (BaseModel, Field, datetime, Optional)
3. Generate edge_type_map dictionary from configuration
4. Include docstrings and field descriptions in generated code
5. Export as .py file or copy to clipboard
6. Syntax validation of generated Python code
7. Version tracking with git-friendly formatting

## Tasks / Subtasks
- [ ] **Task 1: Create Code Generator Service** (AC: 1)
  - [ ] Build OntologyCodeGenerator class
  - [ ] Generate module structure
  - [ ] Order definitions by dependencies
  - [ ] Handle circular dependencies
  - [ ] Add module docstring

- [ ] **Task 2: Generate Import Statements** (AC: 2)
  - [ ] Analyze required imports
  - [ ] Group standard library imports
  - [ ] Group third-party imports
  - [ ] Add type hints imports
  - [ ] Remove unused imports

- [ ] **Task 3: Generate Entity Classes** (AC: 1, 4)
  - [ ] Convert entity definitions to Python
  - [ ] Generate Field() declarations
  - [ ] Add class docstrings
  - [ ] Include field descriptions
  - [ ] Handle default values
  - [ ] Generate validators

- [ ] **Task 4: Generate Edge Classes** (AC: 1, 4)
  - [ ] Convert edge definitions to Python
  - [ ] Generate attribute fields
  - [ ] Add relationship docstrings
  - [ ] Include cardinality info
  - [ ] Generate config classes

- [ ] **Task 5: Create Edge Type Map** (AC: 3)
  - [ ] Generate edge_type_map dictionary
  - [ ] Map edge names to source/target
  - [ ] Include cardinality information
  - [ ] Add fallback patterns
  - [ ] Format as Python dict

- [ ] **Task 6: Add Export Options** (AC: 5)
  - [ ] Create file download functionality
  - [ ] Implement copy to clipboard
  - [ ] Add syntax highlighting in preview
  - [ ] Support multiple file export
  - [ ] Generate requirements.txt

- [ ] **Task 7: Validate and Format** (AC: 6, 7)
  - [ ] Run Python syntax check
  - [ ] Apply Black formatting
  - [ ] Sort imports with isort
  - [ ] Add type checking with mypy
  - [ ] Generate version comment

## Dev Notes

### Code Generator Architecture
```
src/lib/ontology/codegen/
├── OntologyCodeGenerator.ts  # Main generator
├── ImportGenerator.ts        # Import statements
├── EntityGenerator.ts        # Entity classes
├── EdgeGenerator.ts          # Edge classes
├── MapGenerator.ts           # Edge type map
├── ValidatorGenerator.ts     # Custom validators
├── FormatterService.ts       # Code formatting
└── PythonValidator.ts        # Syntax validation
```

### Generation Pipeline
```typescript
class OntologyCodeGenerator {
  private ontology: Ontology
  private entities: EntityTypeDefinition[]
  private edges: EdgeTypeDefinition[]
  
  async generate(): Promise<GeneratedCode> {
    const imports = this.generateImports()
    const entities = this.generateEntities()
    const edges = this.generateEdges()
    const edgeMap = this.generateEdgeTypeMap()
    const helpers = this.generateHelpers()
    
    const code = this.assembleModule(
      imports,
      entities,
      edges,
      edgeMap,
      helpers
    )
    
    const formatted = await this.formatCode(code)
    const validated = await this.validateCode(formatted)
    
    return {
      code: formatted,
      isValid: validated.isValid,
      errors: validated.errors,
      metadata: this.generateMetadata()
    }
  }
}
```

### Import Generation
```typescript
function generateImports(ontology: Ontology): string {
  const imports = new Set<string>()
  
  // Always needed
  imports.add('from pydantic import BaseModel, Field')
  
  // Analyze field types
  const hasOptional = ontology.entities.some(e => 
    e.fields.some(f => f.isOptional)
  )
  if (hasOptional) {
    imports.add('from typing import Optional')
  }
  
  const hasDatetime = ontology.entities.some(e =>
    e.fields.some(f => f.type === 'datetime')
  )
  if (hasDatetime) {
    imports.add('from datetime import datetime')
  }
  
  const hasList = ontology.entities.some(e =>
    e.fields.some(f => f.type.startsWith('list'))
  )
  if (hasList) {
    imports.add('from typing import List')
  }
  
  // Sort imports
  const stdlib = Array.from(imports)
    .filter(i => i.includes('typing') || i.includes('datetime'))
    .sort()
  
  const thirdParty = Array.from(imports)
    .filter(i => i.includes('pydantic'))
    .sort()
  
  return [...stdlib, '', ...thirdParty].join('\n')
}
```

### Entity Class Generation
```python
# Generated Entity Class Template
"""
{module_docstring}

Generated by Krypton Graph v{version}
Date: {timestamp}
Ontology: {ontology_name} v{ontology_version}
"""

{imports}


class {EntityName}(BaseModel):
    """{entity_description}
    
    Attributes:
        {field_name}: {field_description}
    """
    
    # Required fields
    {required_field}: {field_type} = Field(
        ...,
        description="{field_description}",
        {constraints}
    )
    
    # Optional fields
    {optional_field}: Optional[{field_type}] = Field(
        {default_value},
        description="{field_description}",
        {constraints}
    )
    
    # Validators
    @validator('{field_name}')
    def validate_{field_name}(cls, v):
        """{validator_description}"""
        {validation_logic}
        return v
    
    class Config:
        """Pydantic model configuration"""
        use_enum_values = True
        validate_assignment = True
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
```

### Edge Type Map Generation
```python
# Generated Edge Type Map
edge_type_map = {
    "Employment": {
        "source": "Person",
        "target": "Company",
        "cardinality": "n:n",
        "attributes": ["role", "start_date", "end_date", "salary"]
    },
    "Partnership": {
        "source": "Company",
        "target": "Company",
        "cardinality": "n:n",
        "attributes": ["partnership_type", "start_date"]
    },
    "Ownership": {
        "source": ["Person", "Company"],
        "target": "Company",
        "cardinality": "n:n",
        "attributes": ["percentage", "acquisition_date"]
    },
    # Fallback pattern
    "*": {
        "source": "*",
        "target": "*",
        "cardinality": "n:n",
        "attributes": []
    }
}

# Helper function for edge type lookup
def get_edge_type(source_type: str, target_type: str) -> str:
    """Find the appropriate edge type for given source and target"""
    for edge_name, config in edge_type_map.items():
        if edge_name == "*":
            continue
        
        source_match = (
            config["source"] == source_type or
            source_type in config.get("source", []) or
            config["source"] == "*"
        )
        
        target_match = (
            config["target"] == target_type or
            target_type in config.get("target", []) or
            config["target"] == "*"
        )
        
        if source_match and target_match:
            return edge_name
    
    return "*"  # Fallback
```

### Multi-File Export
```typescript
interface ExportPackage {
  files: {
    'ontology.py': string        // Main ontology definitions
    'validators.py': string      // Custom validators
    'test_ontology.py': string   // Unit tests
    'requirements.txt': string   // Dependencies
    'README.md': string         // Documentation
  }
  metadata: {
    version: string
    timestamp: Date
    checksum: string
  }
}

function generateExportPackage(ontology: Ontology): ExportPackage {
  return {
    files: {
      'ontology.py': generateMainModule(ontology),
      'validators.py': generateValidators(ontology),
      'test_ontology.py': generateTests(ontology),
      'requirements.txt': generateRequirements(),
      'README.md': generateDocumentation(ontology)
    },
    metadata: {
      version: ontology.version,
      timestamp: new Date(),
      checksum: calculateChecksum(ontology)
    }
  }
}
```

### Syntax Validation
```typescript
async function validatePythonCode(code: string): Promise<ValidationResult> {
  try {
    // Option 1: Use Pyodide in browser
    const pyodide = await loadPyodide()
    pyodide.runPython(`
import ast
import sys

def validate_syntax(code):
    try:
        ast.parse(code)
        return {"valid": True}
    except SyntaxError as e:
        return {
            "valid": False,
            "error": str(e),
            "line": e.lineno,
            "offset": e.offset
        }
    `)
    
    const result = pyodide.globals.get('validate_syntax')(code)
    return result.toJs()
    
  } catch (error) {
    // Option 2: Send to backend for validation
    const response = await fetch('/api/validate-python', {
      method: 'POST',
      body: JSON.stringify({ code })
    })
    return response.json()
  }
}
```

### Version Tracking
```python
# Version header in generated code
"""
Ontology: Business Domain Model
Version: 1.2.3
Generated: 2025-01-05T10:30:00Z
Checksum: sha256:abcdef123456...
Compatible with: Graphiti v0.3+

Change History:
- v1.2.3 (2025-01-05): Added Partnership edge type
- v1.2.2 (2025-01-04): Updated Person entity fields
- v1.2.1 (2025-01-03): Initial version
"""

# Version metadata
__version__ = "1.2.3"
__ontology_version__ = "1.2.3"
__generated_at__ = "2025-01-05T10:30:00Z"
__generator_version__ = "krypton-graph-1.0.0"
```

### Export Formats
```typescript
interface ExportFormat {
  type: 'file' | 'clipboard' | 'github-gist'
  options?: {
    filename?: string
    format?: 'python' | 'json' | 'yaml'
    minify?: boolean
    includeTests?: boolean
  }
}

async function exportOntology(
  ontology: Ontology,
  format: ExportFormat
): Promise<void> {
  const code = await generateCode(ontology)
  
  switch (format.type) {
    case 'file':
      downloadFile(code, format.options?.filename || 'ontology.py')
      break
    
    case 'clipboard':
      await navigator.clipboard.writeText(code)
      break
    
    case 'github-gist':
      await createGist(code, ontology.name)
      break
  }
}
```

### shadcn-ui Components to Use
- Card (export options)
- Tabs (preview/export/validate)
- Button (generate/export actions)
- Select (format options)
- Code block (preview)
- Alert (validation errors)
- Dialog (export options)
- Toast (success notifications)

### Testing Standards
- Test code generation accuracy
- Validate import statements
- Test edge map generation
- Verify Python syntax
- Test multi-file export
- Check version tracking

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-05 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-01-05 | 1.1 | Reviewed and approved for development | Bob (Scrum Master) |
| 2025-01-08 | 1.2 | Applied QA fixes for circular dependencies, security, and performance | James (Dev) |

## Dev Agent Record
*QA fixes applied on 2025-01-08*

### Agent Model Used
claude-opus-4-1-20250805

### Debug Log References
- Implemented topological sort with cycle detection for dependency ordering
- Updated PythonValidator to use AST parsing without exec/eval
- Created Web Worker implementation for large ontology handling
- Added comprehensive tests for DependencyResolver
- All tests passing: 10/10 tests in DependencyResolver.test.ts
- Lint validation passed: 0 errors, 0 warnings

### Completion Notes List
- ARCH-001: Implemented DependencyResolver with topological sort and cycle detection algorithm
- SEC-002: Refactored PythonValidator to use safe AST parsing, removed all exec/eval usage
- PERF-001: Created CodeGeneratorWorker for Web Worker based processing of large ontologies
- Added fallback strategies for circular dependency handling
- Implemented performance optimization with automatic worker selection based on ontology size

### File List
- src/lib/ontology/codegen/DependencyResolver.ts (new)
- src/lib/ontology/codegen/CodeGeneratorWorker.ts (new)
- src/lib/ontology/codegen/__tests__/DependencyResolver.test.ts (new)
- src/lib/ontology/codegen/OntologyCodeGenerator.ts (modified)
- src/lib/ontology/codegen/PythonValidator.ts (modified)

## QA Results

### Review Date: 2025-01-05

### Reviewed By: Quinn (Test Architect)

**Test Design**: Comprehensive test coverage with 25 test scenarios covering code generation, import management, and export functionality. Strong validation for Python syntax and dependency ordering.

**Risk Assessment**: Solid code generation architecture with good export capabilities. Concerns around circular dependency resolution algorithm complexity, security risks from code validation execution, and potential performance issues with large ontologies.

### Gate Status

Gate: CONCERNS → docs/qa/gates/3.5-ontology-code-generation-and-export.yml

---
**Story Points**: 5 (2-3 days)
**Sprint**: Sprint 3
**Priority**: P0 - Must Have
**Dependencies**: Stories 3.1, 3.2, and 3.3 must be completed first