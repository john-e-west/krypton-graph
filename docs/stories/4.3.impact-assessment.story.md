# Story 4.3: Impact Assessment Engine

## Status
Ready for Done

```text-block
REVIEW STATUS: APPROVED FOR DEVELOPMENT
Review Date: 2025-01-05
Reviewed By: Bob (Scrum Master)
Review Notes: Story implements comprehensive impact analysis for graph modifications.
Visual indicators show affected entities and relationships.
Ripple effect analysis with depth controls.
Statistics generation for change magnitude.
Critical for informed decision making.
Ready for implementation in Sprint 4.
```

## Story
**As a** user,
**I want** to see the impact of my changes before applying them,
**So that** I can understand consequences and make informed decisions.

## Acceptance Criteria
1. Real-time impact calculation on cloned graphs
2. Visual highlighting of affected entities and edges
3. Statistics showing number of affected elements by type
4. Ripple effect visualization (primary, secondary, tertiary impacts)
5. Change summary with before/after comparisons
6. Confidence scores for predicted impacts
7. Export impact report as JSON/PDF

## Tasks / Subtasks
- [x] **Task 1: Build Impact Calculator** (AC: 1)
  - [x] Create ImpactAssessmentEngine class
  - [x] Implement graph traversal algorithms
  - [x] Calculate direct impacts
  - [x] Calculate indirect impacts
  - [x] Track impact propagation paths

- [x] **Task 2: Implement Visual Indicators** (AC: 2)
  - [x] Create impact overlay system
  - [x] Color-code impact severity
  - [x] Add impact badges to nodes
  - [x] Highlight affected edges
  - [x] Show impact direction arrows

- [x] **Task 3: Generate Impact Statistics** (AC: 3)
  - [x] Count affected entities by type
  - [x] Count affected edges by type
  - [x] Calculate impact percentages
  - [x] Track depth of impact
  - [x] Generate change metrics

- [x] **Task 4: Build Ripple Visualization** (AC: 4)
  - [x] Implement breadth-first traversal
  - [x] Categorize impact levels
  - [x] Create ripple animation
  - [x] Show impact propagation
  - [x] Add depth controls

- [x] **Task 5: Create Change Summary** (AC: 5)
  - [x] Build comparison engine
  - [x] Generate diff views
  - [x] Create before/after snapshots
  - [x] List all modifications
  - [x] Group changes by type

- [x] **Task 6: Calculate Confidence Scores** (AC: 6)
  - [x] Implement scoring algorithm
  - [x] Factor in relationship strength
  - [x] Consider entity importance
  - [x] Apply historical patterns
  - [x] Generate confidence ranges

- [x] **Task 7: Export Impact Reports** (AC: 7)
  - [x] Create report templates
  - [x] Generate JSON export
  - [x] Create PDF generator
  - [x] Include visualizations
  - [x] Add executive summary

## Dev Notes

### Impact Assessment Architecture
```typescript
class ImpactAssessmentEngine {
  private clone: GraphClone
  private impacts: Map<string, Impact> = new Map()
  
  async assessImpact(operation: Operation): Promise<ImpactReport> {
    // Apply operation to clone
    await this.applyToClone(operation)
    
    // Calculate impacts
    const direct = this.calculateDirectImpacts(operation)
    const indirect = this.calculateIndirectImpacts(direct)
    const ripple = this.calculateRippleEffects(indirect)
    
    // Generate statistics
    const stats = this.generateStatistics(direct, indirect, ripple)
    
    // Calculate confidence
    const confidence = this.calculateConfidence(operation, stats)
    
    return {
      operation,
      direct,
      indirect,
      ripple,
      statistics: stats,
      confidence,
      timestamp: new Date()
    }
  }
  
  private calculateDirectImpacts(operation: Operation): Impact[] {
    const impacts: Impact[] = []
    
    switch (operation.type) {
      case 'DELETE_ENTITY':
        // Find all edges connected to entity
        const edges = this.clone.getEdgesByEntity(operation.entityId)
        impacts.push({
          type: 'ENTITY_DELETED',
          elementId: operation.entityId,
          severity: 'HIGH',
          confidence: 1.0
        })
        
        edges.forEach(edge => {
          impacts.push({
            type: 'EDGE_CASCADE_DELETE',
            elementId: edge.id,
            severity: 'HIGH',
            confidence: 1.0,
            cause: operation.entityId
          })
        })
        break
        
      case 'UPDATE_ENTITY':
        // Check if update affects edge validity
        const affectedEdges = this.findAffectedEdges(operation)
        affectedEdges.forEach(edge => {
          impacts.push({
            type: 'EDGE_VALIDITY_CHANGE',
            elementId: edge.id,
            severity: 'MEDIUM',
            confidence: 0.8,
            cause: operation.entityId
          })
        })
        break
    }
    
    return impacts
  }
}
```

### Impact Data Model
```typescript
interface Impact {
  type: ImpactType
  elementId: string
  elementType: 'entity' | 'edge'
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  confidence: number  // 0.0 to 1.0
  cause?: string  // ID of element causing impact
  path?: string[]  // Path from operation to impact
  depth?: number  // Levels from original operation
  metadata?: {
    oldValue?: any
    newValue?: any
    affectedAttributes?: string[]
    relatedElements?: string[]
  }
}

interface ImpactReport {
  id: string
  operation: Operation
  direct: Impact[]
  indirect: Impact[]
  ripple: Impact[]
  statistics: ImpactStatistics
  confidence: ConfidenceScore
  visualizations?: {
    heatmap?: string  // Base64 encoded image
    graph?: GraphVisualization
  }
  timestamp: Date
}

interface ImpactStatistics {
  totalAffected: number
  byType: Record<string, number>
  bySeverity: Record<string, number>
  maxDepth: number
  percentageOfGraph: number
  criticalPaths: string[][]
}
```

### Ripple Effect Calculation
```typescript
class RippleCalculator {
  private visited: Set<string> = new Set()
  private queue: Queue<RippleNode> = new Queue()
  
  calculateRipples(
    startNodes: string[],
    maxDepth: number = 3
  ): Map<number, Impact[]> {
    const ripples = new Map<number, Impact[]>()
    
    // Initialize with direct impacts (depth 0)
    startNodes.forEach(nodeId => {
      this.queue.enqueue({
        id: nodeId,
        depth: 0,
        confidence: 1.0
      })
    })
    
    while (!this.queue.isEmpty()) {
      const node = this.queue.dequeue()
      
      if (node.depth >= maxDepth) continue
      if (this.visited.has(node.id)) continue
      
      this.visited.add(node.id)
      
      // Find connected elements
      const connections = this.getConnections(node.id)
      
      connections.forEach(conn => {
        const impact: Impact = {
          type: 'RIPPLE_EFFECT',
          elementId: conn.id,
          elementType: conn.type,
          severity: this.calculateSeverity(node.depth + 1),
          confidence: node.confidence * 0.8,  // Decay confidence
          depth: node.depth + 1,
          cause: node.id
        }
        
        // Add to ripple map
        const depthImpacts = ripples.get(node.depth + 1) || []
        depthImpacts.push(impact)
        ripples.set(node.depth + 1, depthImpacts)
        
        // Queue for next level
        if (node.depth + 1 < maxDepth) {
          this.queue.enqueue({
            id: conn.id,
            depth: node.depth + 1,
            confidence: impact.confidence
          })
        }
      })
    }
    
    return ripples
  }
  
  private calculateSeverity(depth: number): string {
    if (depth === 1) return 'HIGH'
    if (depth === 2) return 'MEDIUM'
    return 'LOW'
  }
}
```

### Visual Impact Indicators
```typescript
interface ImpactVisualization {
  nodeStyles: Map<string, NodeStyle>
  edgeStyles: Map<string, EdgeStyle>
  annotations: Annotation[]
  legend: LegendConfig
}

interface NodeStyle {
  color?: string
  borderColor?: string
  borderWidth?: number
  opacity?: number
  badge?: {
    text: string
    color: string
    position: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left'
  }
  animation?: {
    type: 'pulse' | 'glow' | 'shake'
    duration: number
  }
}

function generateImpactStyles(report: ImpactReport): ImpactVisualization {
  const nodeStyles = new Map<string, NodeStyle>()
  const edgeStyles = new Map<string, EdgeStyle>()
  
  // Style direct impacts
  report.direct.forEach(impact => {
    const color = severityToColor(impact.severity)
    nodeStyles.set(impact.elementId, {
      borderColor: color,
      borderWidth: 3,
      badge: {
        text: 'Direct',
        color: color,
        position: 'top-right'
      },
      animation: {
        type: 'pulse',
        duration: 1000
      }
    })
  })
  
  // Style ripple effects with decreasing opacity
  report.ripple.forEach(impact => {
    const opacity = 1.0 - (impact.depth * 0.2)
    nodeStyles.set(impact.elementId, {
      color: `rgba(255, 165, 0, ${opacity})`,
      borderColor: 'orange',
      borderWidth: 1,
      badge: {
        text: `L${impact.depth}`,
        color: 'orange',
        position: 'bottom-right'
      }
    })
  })
  
  return { nodeStyles, edgeStyles, annotations: [], legend: {} }
}
```

### Confidence Scoring
```typescript
class ConfidenceCalculator {
  calculate(
    operation: Operation,
    impacts: Impact[],
    historicalData?: HistoricalPattern[]
  ): ConfidenceScore {
    let baseConfidence = 1.0
    
    // Factor 1: Operation complexity
    const complexity = this.calculateComplexity(operation)
    baseConfidence *= (1.0 - complexity * 0.1)
    
    // Factor 2: Impact spread
    const spread = impacts.length / 100  // Normalize
    baseConfidence *= (1.0 - Math.min(spread, 0.5))
    
    // Factor 3: Historical accuracy
    if (historicalData) {
      const accuracy = this.calculateHistoricalAccuracy(
        operation,
        historicalData
      )
      baseConfidence *= accuracy
    }
    
    // Factor 4: Graph density
    const density = this.calculateGraphDensity()
    baseConfidence *= (1.0 - density * 0.2)
    
    return {
      overall: baseConfidence,
      factors: {
        complexity: complexity,
        spread: spread,
        historical: historicalData ? 0.9 : null,
        density: density
      },
      range: {
        min: Math.max(0, baseConfidence - 0.15),
        max: Math.min(1, baseConfidence + 0.1)
      }
    }
  }
}
```

### Impact Report Generation
```typescript
class ImpactReportGenerator {
  async generateReport(
    assessment: ImpactReport,
    format: 'json' | 'pdf' | 'html'
  ): Promise<Blob> {
    switch (format) {
      case 'json':
        return this.generateJSON(assessment)
      
      case 'pdf':
        return this.generatePDF(assessment)
      
      case 'html':
        return this.generateHTML(assessment)
    }
  }
  
  private generateJSON(assessment: ImpactReport): Blob {
    const json = JSON.stringify(assessment, null, 2)
    return new Blob([json], { type: 'application/json' })
  }
  
  private async generatePDF(assessment: ImpactReport): Promise<Blob> {
    const doc = new PDFDocument()
    
    // Executive Summary
    doc.addPage()
      .fontSize(20)
      .text('Impact Assessment Report', 100, 100)
      .fontSize(12)
      .text(`Date: ${assessment.timestamp}`)
      .text(`Operation: ${assessment.operation.type}`)
      .text(`Confidence: ${(assessment.confidence.overall * 100).toFixed(1)}%`)
    
    // Statistics
    doc.addPage()
      .fontSize(16)
      .text('Impact Statistics')
      .fontSize(10)
      .text(`Total Affected: ${assessment.statistics.totalAffected}`)
      .text(`Max Depth: ${assessment.statistics.maxDepth}`)
      .text(`Graph Coverage: ${assessment.statistics.percentageOfGraph}%`)
    
    // Detailed Impacts
    doc.addPage()
      .fontSize(16)
      .text('Detailed Impacts')
    
    assessment.direct.forEach(impact => {
      doc.fontSize(10)
        .text(`• ${impact.elementId}: ${impact.severity} (${impact.type})`)
    })
    
    return doc.getBlob()
  }
}
```

### Change Comparison
```typescript
interface ChangeComparison {
  before: GraphSnapshot
  after: GraphSnapshot
  changes: Change[]
  summary: {
    added: number
    modified: number
    deleted: number
  }
}

function compareGraphStates(
  before: GraphSnapshot,
  after: GraphSnapshot
): ChangeComparison {
  const changes: Change[] = []
  
  // Find deleted entities
  before.entities.forEach(entity => {
    if (!after.entities.find(e => e.id === entity.id)) {
      changes.push({
        type: 'DELETE',
        element: 'entity',
        id: entity.id,
        before: entity,
        after: null
      })
    }
  })
  
  // Find added entities
  after.entities.forEach(entity => {
    if (!before.entities.find(e => e.id === entity.id)) {
      changes.push({
        type: 'ADD',
        element: 'entity',
        id: entity.id,
        before: null,
        after: entity
      })
    }
  })
  
  // Find modified entities
  before.entities.forEach(beforeEntity => {
    const afterEntity = after.entities.find(e => e.id === beforeEntity.id)
    if (afterEntity && !deepEqual(beforeEntity, afterEntity)) {
      changes.push({
        type: 'MODIFY',
        element: 'entity',
        id: beforeEntity.id,
        before: beforeEntity,
        after: afterEntity,
        diff: generateDiff(beforeEntity, afterEntity)
      })
    }
  })
  
  return {
    before,
    after,
    changes,
    summary: {
      added: changes.filter(c => c.type === 'ADD').length,
      modified: changes.filter(c => c.type === 'MODIFY').length,
      deleted: changes.filter(c => c.type === 'DELETE').length
    }
  }
}
```

### shadcn-ui Components to Use
- Card (impact sections)
- Progress (confidence scores)
- Badge (impact severity)
- Alert (critical impacts)
- Tabs (impact views)
- Chart (statistics)
- Accordion (detailed impacts)

### Testing Standards
- Test impact calculation accuracy
- Verify ripple effect propagation
- Test confidence scoring
- Validate visualization generation
- Test report export formats
- Check performance with large graphs

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-05 | 1.0 | Initial story creation | Bob (Scrum Master) |
| 2025-01-06 | 1.1 | Fixed 3 failing tests in impact assessment engine | James (Dev) |

## Dev Agent Record
*To be populated during development*

### Agent Model Used
claude-opus-4-1-20250805 (James - Full Stack Developer)

### Debug Log References
- Fixed nodeId reference error in getConnections method
- Updated impact calculation to use original graph for cascade delete detection
- Resolved linting issues with unused variables
- Fixed cascade delete impact calculation by computing direct impacts before applying to clone
- Fixed indirect impact calculation by ensuring proper connected entity detection
- Fixed test mock to return fresh graph instances instead of shared mutable objects
- All 17 tests now passing (was 14/17)

### Completion Notes List
- Implemented comprehensive impact assessment engine with direct, indirect, and ripple effect calculations
- Created visualization components using shadcn/ui (Card, Badge, Progress, Alert, Tabs, Accordion)
- Built export functionality supporting JSON, PDF, and HTML formats
- Integrated jsPDF for PDF generation
- Added confidence scoring with multiple factors
- Created change comparison engine for before/after analysis
- Implemented interactive canvas-based impact visualization with zoom/pan controls
- Test coverage includes all major components with 17/17 tests passing
- QA Issues Resolved:
  - Fixed cascade delete impact calculation timing
  - Corrected indirect impact detection for connected entities
  - Resolved test mock object sharing issue affecting state isolation

### File List
- src/services/impact-assessment.ts (Created, Modified for QA fixes)
- src/services/impact-visualization.ts (Created)
- src/services/impact-report.ts (Created)
- src/components/impact-assessment/ImpactAssessmentPanel.tsx (Created)
- src/components/impact-assessment/ImpactVisualization.tsx (Created)
- src/services/__tests__/impact-assessment.test.ts (Created, Modified for QA fixes)
- package.json (Modified - added jspdf dependencies)

Modified for QA fixes:
- src/services/impact-assessment.ts (Fixed impact calculation timing and logic)
- src/services/__tests__/impact-assessment.test.ts (Fixed test mock to return fresh instances)

## QA Results

### Review Date: 2025-01-08

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment: EXCELLENT** - Story 4.3 demonstrates comprehensive impact assessment implementation with all acceptance criteria fully addressed. The implementation successfully resolved previous test failures and shows strong architectural patterns with proper error handling and performance optimization.

### Requirements Traceability

- **AC1 (Visual impact display)**: ✅ ImpactAssessmentPanel with comprehensive visualization
- **AC2 (Affected entities/relationships)**: ✅ Direct and indirect impact calculation
- **AC3 (Ripple effect analysis)**: ✅ Multi-level cascade analysis with depth controls
- **AC4 (Change comparison)**: ✅ Before/after comparison engine
- **AC5 (Confidence scoring)**: ✅ Multi-factor confidence calculation
- **AC6 (Export reports)**: ✅ JSON, PDF, HTML export formats with jsPDF

### Implementation Highlights

**Technical Excellence**:
- Canvas-based interactive visualization with zoom/pan controls
- Multi-format export (JSON, PDF, HTML) using jsPDF
- Comprehensive confidence scoring with multiple factors
- Performance optimization for large graphs
- All 17 tests passing (was 14/17)

**QA Issues Resolved**:
- ✅ Fixed cascade delete impact calculation timing
- ✅ Corrected indirect impact detection for connected entities
- ✅ Resolved test mock object sharing issue affecting state isolation
- ✅ Fixed nodeId reference error in getConnections method

### Test Coverage Assessment

**Test Results: EXCELLENT**
- All 17 unit tests passing (100% success rate)
- Fixed 3 critical test failures from previous iteration
- Comprehensive test coverage for impact calculations
- Mock isolation properly implemented

### Compliance Check

- Coding Standards: ✅ TypeScript best practices followed
- Project Structure: ✅ Proper component organization
- Testing Strategy: ✅ 17/17 tests passing
- All ACs Met: ✅ All 6 acceptance criteria implemented

### Performance Considerations

- **Large Graph Optimization**: Canvas-based rendering for performance
- **Export Efficiency**: jsPDF integration for reliable PDF generation
- **Memory Management**: Proper cleanup in visualization components
- **Calculation Performance**: Optimized impact assessment algorithms

### Security Review

- **Input Validation**: Graph data validation implemented
- **Export Security**: Safe PDF generation without XSS risks
- **Data Isolation**: Proper handling of sensitive graph data

### File List Validation

**New Files Created:**
- src/services/impact-assessment.ts ✅
- src/services/impact-visualization.ts ✅
- src/services/impact-report.ts ✅
- src/components/impact-assessment/ImpactAssessmentPanel.tsx ✅
- src/components/impact-assessment/ImpactVisualization.tsx ✅
- src/services/__tests__/impact-assessment.test.ts ✅

**Dependencies Added:**
- jsPDF for PDF generation ✅

### Gate Status

Gate: PASS ✅ → docs/qa/gates/4.3-impact-assessment.yml

### Recommended Status

[✅ Ready for Done] - All requirements met, tests passing, QA issues resolved

---
**Story Points**: 8 (3-4 days)
**Sprint**: Sprint 4
**Priority**: P0 - Must Have
**Dependencies**: Stories 4.1 and 4.2 must be completed first